

import Token.JavaSymbol;
import Token.sym.*;
import java_cup.runtime.*;
import java.io.*;
import java.util.*;
import analizador_lexico.*;
import generador.*;
import java.util.ArrayList;
import Token.sym.*;
//import static Token.sym.IDENTIFIER;


parser code  {: 
  public static int errors = 0;
  public static int warnings = 0;
  public static analizador_lexico.Scanner s;
  public static ArrayList<Token> tokens = new ArrayList<Token>();
    public static ArrayList<String> identis = new ArrayList<String>();
  public String RESULT= "Pila SEGMENT STACK\n\tdb 64 dup (?)\nPila ENDS\n\ndatos segment\n";
  public static ArrayList<String> funciones = new ArrayList<String>();
  public static Pila pila = new Pila();
  public String MAIN = "";
  public String FUNCIONES= "";
  public int cont_while=1;
  public int cont_if=1;
  public int cont_else=1;
  public int cont_bucles =0;
  public boolean esReturn=false;


  public static void main(String argv[]) {

    for (int i = 0; i < argv.length; i++) {
      try {
	  s = new analizador_lexico.Scanner(new FileReader(argv[i]));
        Parser p = new Parser(s);
        p.parse();
        System.out.println("Number of errors = " + errors + ".");
       

      }
      catch (Exception e) {
        e.printStackTrace(System.out);
        System.exit(1);
      }
    }
  }
    protected int error_sync_size () {
        //System.out.println(":error_sync_size was called.");
        return 1; // not recommended by the CUP manual
}
  public void report_error(String message, Object info) {
    if (info instanceof String){
	errors++; 
      System.err.println("  "+ errors + "==> " + info + " "+ message + 
					"\n       Parsing resumed from 2nd token before" + s.current_lexeme()+"\n");
    }
    else {
    	StringBuffer m = new StringBuffer("Error ");
    	if (info instanceof java_cup.runtime.Symbol) 
     	   m.append( "("+info.toString()+")" );     
    	m.append(" : "+message);   
    	System.err.println(m);
    }
  }
   
  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    throw new RuntimeException("Fatal Syntax Error");
  }

// IDENTIFICADORES
public void recuerda_tipo()
{
    Tipo Reg_Tipo = new Tipo(s.yytext());
    pila.Push(Reg_Tipo); 
}
public void recuerda_id(Object type)
{
    
    Identificador temp = new Identificador(type.toString(),-1);
    //tokens.add(new Token(new Symbol(79,type.toString())));
    pila.Push(temp);
}
public void valor_id(Object valor)
{
    if(valor!= null){
        Literal temp = new Literal(valor.toString());
        pila.Push(temp);
    }
    else{
        Literal temp = new Literal("0");
        pila.Push(temp);
    }
}

public void inserta_TS()
{
    IData temp;
    boolean pasa = true;
    while(!pila.isEmpty()){
        temp = pila.Pop();
        if(temp.getTipo()==1){
            if(identis.contains(temp.valor())){
                 // EL IDENTIFICADOR YA HA SIDO AGREGADO
                 System.err.println("ERROR SEMANTICO: identificador "+ temp.valor()+" anteriormente instanciado");
                 pasa = false;
            }
            else{
                RESULT += temp.CodigoGenerar();
                identis.add(temp.valor());
            }
        }
        else{
        if(pasa)
            RESULT += temp.CodigoGenerar();
        
        else{
            pasa = true;
            // SE DEBE OMITIR EL AGREGAR, ya que es un valor inicial para un Error Semantico
        }
        }
    }
}

// FUNCIONES
public void crear_slot_funcion()
{
    pila.Push(new Funcion(""));
}
public void funcion_Insertar(Object nombre)
{
    if(nombre.toString().equals("main"))
    {
        funciones.add(nombre.toString());
        MAIN += "main:\n";
        // HACER TODAS LAS COSAS CON LA PILA SEMENTICA
        Funcion temp = (Funcion) pila.Pop();
        MAIN += temp.valor();

        // VIENE EL CIERRE DEL PROGRAMA
        MAIN += "\ncierre:\n";
        MAIN += "\tmov ah,4ch\n";
        MAIN += "\tmov al,07h\n";
            
        MAIN += "\tint 21h\n\n";
        MAIN += "codigo endS\n";
        MAIN += "end main";

    }
    else{
        funciones.add(nombre.toString());
        FUNCIONES += nombre.toString()+" Proc Near\n";
        
        //HACER TODAS LAS COSAS CON LA PILA SEMANTICA
        Funcion temp = (Funcion) pila.Pop();
        FUNCIONES += temp.valor();

        FUNCIONES += nombre.toString()+" endP\n\n";
    }
}

public void revisar_Main()
{
    if(!funciones.contains("main"))
    {
        System.err.println("ERROR SEMANTICO: No se declaro ningun MAIN");
    }
    RESULT += FUNCIONES + MAIN;
}

// REVISAR RETURN
public void revisar_Return()
{
    cont_bucles--;
    if(esReturn && cont_bucles==0)
    {
        System.err.println("ERROR SEMANTICO: No se declaro return en la funcion");
        esReturn = false;
    }
}

// WHILE

public void iniciar_while()
{
    String temp = ((Funcion)pila.Pop()).valor();
    temp += "start_while"+cont_while+":\n";
    pila.Push(new Funcion(temp));
}
public void evaluar_while()
{
    String oper="<=";
    String temp = ((Funcion)pila.Pop()).valor();
    temp += "\tCMP OBJ1,OBJ2\n";
    
    if(oper.equals("<=")){
        temp+= "\tJLE end_while"+cont_while+"\n";
    }
    else if(oper.equals("=<")){
        temp+= "\tJGE end_while"+cont_while+"\n";    
    }
    else if(oper.equals("!=")){
        temp+= "\tJNE end_while"+cont_while+"\n";    
    }
    else if(oper.equals("==")){
        temp+= "\tJE end_while"+cont_while+"\n";    
    }
    else if(oper.equals("<")){
        temp+= "\tJL end_while"+cont_while+"\n";    
    }
    else if(oper.equals(">")){
        temp+= "\tJG end_while"+cont_while+"\n";    
    }
    else if(oper.equals("||")){
        temp+= "\tNULL end_while"+cont_while+"\n";    
    }
    else if(oper.equals("&&")){
        temp+= "\tNULL end_while"+cont_while+"\n";    
    }
    pila.Push(new Funcion(temp));
}
public void terminar_while()
{
    String temp = ((Funcion)pila.Pop()).valor();
    temp +="\tJUMP start_while"+cont_while+"\n";
    temp +="end_while"+cont_while+":\n";
    cont_while++;
    pila.Push(new Funcion(temp));
}
:};

action code {:
	

:};

// PALABRAS RESERVADAS
  terminal BOOLEAN ;//"boolean"                     
  terminal CHAR; //"char"                       
  terminal ELSE; //"else"                         
  terminal INT; //"int"                          
  terminal IF; //"if"                         
  terminal PUBLIC; //"public"                       
  terminal RETURN; //"return"                      
  terminal VOID; //"void"                        
  terminal WHILE; //"while"                       
  terminal FLOAT; // "float"                       
  terminal LONG; // "long"                                              
  terminal SHORT; //"short"                       
  terminal BREAK; //"break"                                              
  terminal CASE; //"case"                       
  terminal CONTINUE; //"continue"                                                   
  terminal DEFAULT; //"default"                        
  terminal DO; //"do"                                                
  terminal FOR; //"for"                       
  terminal SWITCH; //"switch"                                              
  terminal READ; //"read"                                                
  terminal WRITE; //"write"                        

  terminal UNSIGNED ;
  terminal AUTO;
  terminal STATIC;
  terminal ENUM;
  terminal EXTERN;
  terminal GOTO;
  terminal REGISTER;
  terminal SIGNED;
  terminal SIZEOF;
  terminal STRUCT;
  terminal TYPEDEF;
  terminal VOLATILE;
  terminal MAIN;

  // SEPARADORES

  terminal LBRACE; //"{"                            
  terminal RBRACE; //"}"                            
  terminal LBRACK; //"["                            
  terminal RBRACK; //"]"                            
  terminal SEMICOLON; //";"                            
  terminal COMMA; //","                            
  terminal DOT; //"."                            
  terminal NOT; //"!"                            
  terminal QUESTION; // "?"                            
  terminal COLON; //":"                            

 // ARITMETICOS
  terminal PLUS; //"+"                            
  terminal MINUS; //"-"                            
  terminal MULT; //"*"                            
  terminal DIV; //"/"                            
  terminal MOD; //"%"                            
  terminal PLUS_PLUS; //"++"                            
  terminal MINUS_MINUS; //"--"                            
  terminal PLUS_EQ; //"+="                            
  terminal MINUS_EQ; //"-="                            
  terminal MULT_EQ; //"*="                            
  terminal DIV_EQ; // "/=" 
   
terminal GT_GT;//">>"                     
terminal LT_LT;//"<<"                     
terminal TOS;//"~"                      
terminal MOD_EQ;//"%="                     
terminal AT_EQ;//"&="                     
terminal UP_EQ;//"^="                     
terminal OR_EQ;//"|="                     
terminal LT_LT_EQ;//"<<="                    
terminal GT_GT_EQ;//">>="                    
terminal POINTER;//"->"                     
    
  terminal LPAREN; // "("                            
  terminal RPAREN; //")"                            
  terminal EQ; //"="                            
                        
// BOOLEANOS
terminal EQEQ; //  "=="                           
terminal LTEQ; //  "<="                           
terminal GTEQ; // ">="                          
terminal NOTEQ; //  "!="                           
terminal ANDAND; //  "&&"                           
terminal AT; //  "&"          			   
terminal OROR; //  "||"                           
terminal GT; //  ">"                            
terminal LT; //  "<"                            

// IDENTIFICADOR
terminal java.lang.String IDENTIFIER; // name

// LITERALES
terminal java.lang.Number INTEGER_LITERAL;
terminal java.lang.Number FLOATING_POINT_LITERAL;
terminal java.lang.Boolean BOOLEAN_LITERAL;
terminal java.lang.Character CHARACTER_LITERAL;
terminal java.lang.String STRING_LITERAL;

terminal HEX_LITERAL;
terminal OCT_LITERAL;
terminal NULL_LITERAL;

// INICIO
non terminal String estructura;

// ESTRUCTURA
non terminal String statement_globales;
non terminal String statement_funciones;
non terminal String cuerpo_funcion;
non terminal String cuerpo_funcion_aux;
non terminal String llamado_funcion;
non terminal String statement_variables_locales_inicio;
non terminal String statement_variables_locales;

    // IF-ELSE -FOR -WHILE
non terminal String statement_if;
non terminal String statement_while;
non terminal String statement_for;  
non terminal String statement_else;  

    // SWITCH
non terminal String statement_switch ;
non terminal String statement_switch_aux;
non terminal String statement_cuerpo_case;

    // CONTINUE - BREAK - RETURN
non terminal String otras_palabras;
non terminal String return_variables;

// DECLARACIONES
non terminal String declaracion_identificador;
non terminal String varios_identificadores;
non terminal String valor_inicial;

non terminal String declaracion_funciones;
non terminal String varios_tipos;

// LITERALES
non terminal String literal;
non terminal String literal_numerico;

// TIPOS
non terminal String type;

// EXPRESIONES
non terminal String expresiones;
non terminal String expresiones_statement;
non terminal String asignacion;
non terminal String expresion_aritmetica;
non terminal String expresion_aritmetica_unaria;
non terminal String expresion_aritmetica_binaria;
non terminal String expresion_booleana;


// OPERADORES
non terminal String operadores_unarios;
non terminal String operadores_binarios;
non terminal String operadores_asignacion;
non terminal String operadores_booleanos;

// READ AND WRITE
non terminal String estructura_read;
non terminal String estructura_read_parametros;

non terminal String estructura_write;
non terminal String estructura_write_parametros;
non terminal String estructura_write_parametros_aux;

// ERROR ****
non terminal String error_semicolon;
non terminal String error_corchete;

// VACIO
non terminal String epsilon;



/* Precedences */
precedence left PLUS, MINUS;
precedence left MULT, DIV, MOD;
precedence left NOT,PLUS_PLUS,MINUS_MINUS;

// GRAMATICA
start with estructura;

estructura ::= 
            statement_globales;            


// PARTE DE GLOBALES
statement_globales ::= 
                declaracion_identificador statement_globales {:RESULT += "datos endS\n\ncodigo segment\n\tASSUME CS:Codigo, DS:Datos, SS:Pila\n\n";:}
        |        declaracion_funciones statement_funciones;              // TIENE QUE HABER UNA FUNCION **** LLAMADO A FUNCIONES

// DECLARACION VARIABLES *******************
declaracion_identificador ::=
                type  IDENTIFIER:i  varios_identificadores valor_inicial SEMICOLON {:parser.recuerda_id(i);parser.inserta_TS();:}
        |       error:e{:parser.report_error("Error Sintactico: Declaracion Identificador",e);:} SEMICOLON;

varios_identificadores    ::=
                COMMA  IDENTIFIER:i  varios_identificadores  {:parser.valor_id(null);parser.recuerda_id(i);:}
        |       epsilon;

valor_inicial             ::=
                epsilon {:parser.valor_id(null);:}
        |       EQ literal_numerico;

// PARTE DE FUNCIONES 
statement_funciones  ::=
                declaracion_funciones statement_funciones
        |       epsilon {:parser.revisar_Main();:};
                

declaracion_funciones ::=
                 type  IDENTIFIER:i {:parser.esReturn= true;parser.cont_bucles++;parser.crear_slot_funcion();:} LPAREN RPAREN cuerpo_funcion           {:parser.funcion_Insertar(i);:}
        |       VOID IDENTIFIER:i {:parser.esReturn= false;parser.cont_bucles++;parser.crear_slot_funcion();:} LPAREN RPAREN cuerpo_funcion                          {:parser.funcion_Insertar(i);:}
        |       error:e{:parser.report_error("Error Sintactico: Statement de Funciones",e);:} RBRACE ; 

varios_tipos            ::=
                COMMA type IDENTIFIER varios_tipos
        |       epsilon;

// CUERPO DE LA FUNCION
cuerpo_funcion          ::=
                LBRACE cuerpo_funcion_aux;                          
                

cuerpo_funcion_aux          ::=
                estructura_read cuerpo_funcion_aux
        |       estructura_write cuerpo_funcion_aux
        |       llamado_funcion cuerpo_funcion_aux
        |       expresiones cuerpo_funcion_aux
        |       statement_if cuerpo_funcion_aux
        |       statement_while cuerpo_funcion_aux
        |       RETURN literal_numerico  SEMICOLON RBRACE {:parser.esReturn=false;parser.cont_bucles=0;:}
        |       RBRACE {:parser.revisar_Return();:};     // SE TERMINA LA FUNCION    



// IF_ELSE **************

statement_if ::=
                IF LPAREN expresiones_statement RPAREN LBRACE cuerpo_funcion_aux statement_else
        |       IF error:e{:parser.report_error("Error Sintactico: Statement en IF",e);:} RBRACE;

statement_else ::=
        |        ELSE LBRACE cuerpo_funcion_aux;

// WHILE

statement_while ::=
                WHILE {:parser.cont_bucles++;parser.iniciar_while();:} LPAREN expresiones_statement {:parser.evaluar_while();:} RPAREN LBRACE cuerpo_funcion_aux {:parser.terminar_while();:}
        |       WHILE error:e{:parser.report_error("Error Sintactico: Statement en WHILE",e);:} RBRACE ;
// FOR

statement_for   ::=
                FOR LPAREN expresiones_statement SEMICOLON expresiones_statement SEMICOLON expresiones_statement RPAREN LBRACE cuerpo_funcion_aux
        |       FOR error:e{:parser.report_error("Error Sintactico: Statement en FOR",e);:} RBRACE ;

// SWITCH *****************

statement_switch    ::=
                SWITCH LPAREN expresiones_statement RPAREN LBRACE statement_switch_aux RBRACE
        |       SWITCH error:e{:parser.report_error("Error Sintactico: Statement en SWITCH",e);:} RBRACE ;

statement_switch_aux     ::=
        |        CASE INTEGER_LITERAL COLON statement_cuerpo_case statement_switch_aux
        |       DEFAULT COLON statement_cuerpo_case statement_switch_aux
        |       CASE error:e{:parser.report_error("Error Sintactico: Statement en CASE",e);:} SEMICOLON 
        |       DEFAULT error:e{:parser.report_error("Error Sintactico: Statement en DEFAULT",e);:} SEMICOLON ;

statement_cuerpo_case         ::=
                estructura_read statement_cuerpo_case
        |       estructura_write statement_cuerpo_case
        |       llamado_funcion statement_cuerpo_case
        |       expresiones statement_cuerpo_case
        |       BREAK SEMICOLON;     // SE TERMINA LA FUNCION  

// CONTINUES, BREAK AND RETURN

otras_palabras  ::=
                CONTINUE SEMICOLON
        |       BREAK   SEMICOLON
        |       RETURN return_variables  SEMICOLON;

return_variables    ::=
                    
        |       literal
        |       IDENTIFIER;

// VARIABLES LOCALES DE FUNCION ******************
statement_variables_locales_inicio ::=
        |       epsilon
                statement_variables_locales;

statement_variables_locales ::=
                declaracion_identificador 
        |       declaracion_identificador statement_variables_locales;  

// OPERADPRES *********************

operadores_unarios ::=
                PLUS_PLUS
        |       MINUS_MINUS;


operadores_binarios ::=
                PLUS
        |       MINUS
        |       MULT
        |       DIV
        |       MOD;

operadores_asignacion ::= 
                EQ
        |       PLUS_EQ
        |       MINUS_EQ
        |       MULT_EQ
        |       DIV_EQ;   


operadores_booleanos ::= 
                OROR
        |       ANDAND
        |       EQEQ
        |       GTEQ
        |       GT
        |       LTEQ
        |       LT
        |       NOTEQ;   

// LITERALES *************************

literal ::=
		INTEGER_LITERAL 
	|	FLOATING_POINT_LITERAL
	|	BOOLEAN_LITERAL 
	|	CHARACTER_LITERAL 
	|	STRING_LITERAL 
        |       HEX_LITERAL
        |       OCT_LITERAL
	|	NULL_LITERAL;

literal_numerico ::=
		INTEGER_LITERAL:v {:parser.valor_id(v);:}
	|	FLOATING_POINT_LITERAL:v {:parser.valor_id(v);:}
        |       HEX_LITERAL:v {:parser.valor_id(v);:}
        |       OCT_LITERAL:v {:parser.valor_id(v);:};

// TIPOS *****************
type	::=
		BOOLEAN
	|	INT
	|	CHAR
	|	FLOAT
        |       LONG
        |       SHORT;




// READ AND WRITE **************

estructura_read    ::=
                READ LPAREN  RPAREN SEMICOLON
        |       READ LPAREN  estructura_read_parametros RPAREN SEMICOLON
        |       READ  error:e{:parser.report_error("Error Sintactico: Uso de READ",e);:}  SEMICOLON ;

estructura_read_parametros  ::=
               IDENTIFIER;

estructura_write   ::=
                WRITE LPAREN  expresiones RPAREN SEMICOLON
        |       WRITE error:e{:parser.report_error("Error Sintactico: Uso de WRITE",e);:} SEMICOLON ;
                
estructura_write_parametros   ::=
                estructura_write_parametros_aux
        |       estructura_write_parametros_aux COMMA estructura_write_parametros;       

estructura_write_parametros_aux   ::=
                 IDENTIFIER
         |       literal;

// LLAMADO A FUNCION ********
llamado_funcion             ::=
                IDENTIFIER LPAREN  RPAREN SEMICOLON
        |       IDENTIFIER LPAREN  estructura_write_parametros_aux RPAREN SEMICOLON
        |       IDENTIFIER error:e{:parser.report_error("Error Sintactico: LLAMADO DE FUNCION",e);:} SEMICOLON ;
               

//      EXPRESIONES
expresiones   ::= 
                  expresiones_statement SEMICOLON;

 
expresiones_statement ::=
                asignacion
        |       expresion_aritmetica  
        |       expresion_booleana ;

asignacion ::= 
                IDENTIFIER operadores_asignacion expresion_aritmetica ;      


expresion_aritmetica ::= 
                 expresion_aritmetica_unaria
        |        expresion_aritmetica_binaria
        |        LPAREN expresion_aritmetica RPAREN
        |        IDENTIFIER 
        |        literal;

expresion_aritmetica_unaria ::= 
                 operadores_unarios IDENTIFIER 
        |        IDENTIFIER operadores_unarios 
        |        MINUS literal_numerico
        |        MINUS IDENTIFIER;

expresion_aritmetica_binaria ::= 
                 expresion_aritmetica operadores_binarios expresion_aritmetica;
        

expresion_booleana ::= 
                  expresion_aritmetica operadores_booleanos expresion_aritmetica
          |       NOT expresion_aritmetica
          |       LPAREN expresion_booleana RPAREN;
// ********** VACIO
epsilon ::= /*nothing */;
        


