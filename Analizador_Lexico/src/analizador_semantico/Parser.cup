

import Token.JavaSymbol;
import Token.sym.*;
import java_cup.runtime.*;
import java.io.*;
import java.util.*;
import analizador_lexico.*;
import generador.*;
import java.util.ArrayList;
import Token.sym.*;
//import static Token.sym.IDENTIFIER;


parser code  {: 
  public static int errors = 0;
  public static int warnings = 0;
  public static analizador_lexico.Scanner s;
  public static ArrayList<Token> tokens = new ArrayList<Token>();
  public static ArrayList<String> identis = new ArrayList<String>();
  public String RESULT= "Pila SEGMENT STACK\n\tdb 64 dup (?)\nPila ENDS\n\ndatos segment\n";
  public static ArrayList<String> funciones = new ArrayList<String>();
  public static Pila pila = new Pila();
  public String MAIN = "";
  public String WRITE_MACRO ="write Macro numero\n\tmov al,numero\n\taam\n\tadd ax,3030h\n\txchg al,ah\n\tint 29h\n\tmov al,ah\n\tint 29h\nendM\n";
  public String READ_MACRO = "read Macro\n\tmov ah,01h\n\tint 21h\n\tsub al,48\nendM\n";
  public String FUNCIONES= "datos endS\n\n"+WRITE_MACRO+READ_MACRO+"codigo segment\n\tASSUME CS:Codigo, DS:Datos, SS:Pila\n\n";
  public int cont_while=1;
  public int cont_if=1;
  public int cont_else=1;
  public int cont_bucles =0;
  public boolean esReturn=false;

  private int label_n = 0;

  public String RESULT2 = "";


  public static void main(String argv[]) {

    for (int i = 0; i < argv.length; i++) {
      try {
	  s = new analizador_lexico.Scanner(new FileReader(argv[i]));
        Parser p = new Parser(s);
        p.parse();
        System.out.println("Number of errors = " + errors + ".");
       

      }
      catch (Exception e) {
        e.printStackTrace(System.out);
        System.exit(1);
      }
    }
  }
  protected int error_sync_size () {
        //System.out.println(":error_sync_size was called.");
        return 1; // not recommended by the CUP manual
}
  public void report_error(String message, Object info) {
    if (info instanceof String){
	errors++; 
      System.err.println("  "+ errors + "==> " + info + " "+ message + 
					"\n       Parsing resumed from 2nd token before" + s.current_lexeme()+"\n");
    }
    else {
    	StringBuffer m = new StringBuffer("Error ");
    	if (info instanceof java_cup.runtime.Symbol) 
     	   m.append( "("+info.toString()+")" );     
    	m.append(" : "+message);   
    	System.err.println(m);
    }
  }
   
  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    throw new RuntimeException("Fatal Syntax Error");
  }

// IDENTIFICADORES
public void recuerda_tipo()
{
    Tipo Reg_Tipo = new Tipo(s.yytext());
    pila.Push(Reg_Tipo); 
}
public void recuerda_id(Object type)
{
    
    Identificador temp = new Identificador(type.toString(),-1);
    //tokens.add(new Token(new Symbol(79,type.toString())));
    pila.Push(temp);
}
public void valor_id(Object valor)
{
    if(valor!= null){
        Literal temp = new Literal(valor.toString());
        pila.Push(temp);
    }
    else{
        Literal temp = new Literal("0");
        pila.Push(temp);
    }
}


public void inserta_TS()
{
    IData temp;
    boolean pasa = true;
    while(!pila.isEmpty()){
        temp = pila.Pop();
        if(temp.getTipo()==1){
            if(identis.contains(temp.valor())){
                 // EL IDENTIFICADOR YA HA SIDO AGREGADO
                 System.err.println("ERROR SEMANTICO: identificador "+ temp.valor()+" anteriormente instanciado");
                 pasa = false;
            }
            else{
                RESULT += temp.CodigoGenerar();
                identis.add(temp.valor());
            }
        }
        else{
        if(pasa)
            RESULT += temp.CodigoGenerar();
        
        else{
            pasa = true;
            // SE DEBE OMITIR EL AGREGAR, ya que es un valor inicial para un Error Semantico
        }
        }
    }
}

//EXPRESIONES ------------------------------------------------------------------------------------
//Crea un registro Identificador y lo guarda en la pila
public void identificador(Object id)
{
   Identificador temp = new Identificador(id.toString(),-1);

   if(verificar_TS(temp)){pila.Push(temp);}
   else{System.err.println("ERROR SEMANTICO: variable "+ temp.valor()+" no declarada");}
}

//Verifica si ya el id esta en la tabla de simbolos
public boolean verificar_TS(Identificador variable){

        if(identis.contains(variable.valor())){
            return true;
        }
        else{
            return false;
        }
}
//Crea un registro Literal y lo mete a la pila
public void literal(Object valor){

    if(valor!= null){
        Literal temp = new Literal(valor.toString());
        pila.Push(temp);
    }
    else{
        Literal temp = new Literal("0");
        pila.Push(temp);}
}

//Crea un registro operador y lo mete a la pila
public void operador(Object operator){

      Operador temp = new Operador(operator.toString());
      pila.Push(temp);
}

public void evaluar_binario(){

IData OperandoDerecho = pila.Pop();
IData Operador = pila.Pop();
IData OperandoIzquierdo = pila.Pop();

//Evaluar Tipo - No hayb que evaluar 

generar_expresion_binaria(OperandoDerecho, Operador, OperandoIzquierdo);

pila.Push(new Identificador("resultado", -1));

}

public void  generar_expresion_binaria(IData OperandoDerecho, IData Operador, IData OperandoIzquierdo){

   String etiqueta = "L" + label_n;

   switch(Operador.valor()){
      case "+": RESULT2 = RESULT2 + "\nmov ax, "  + OperandoDerecho.valor() + 
                                    "\nadd ax, " + OperandoIzquierdo.valor();
                break;
      case "-": RESULT2 = RESULT2 + "\nmov ax, "  + OperandoDerecho.valor() +
                                    "\nsub ax, " + OperandoIzquierdo.valor();
                break;
      case "=": RESULT2 = RESULT2 + "\nmov "  + OperandoIzquierdo.valor() +  ", ax";
                break;

      case "==":RESULT2 = RESULT2 + "\nmov ax, "  + OperandoDerecho.valor() + 
                                    "\ncmp ax, "  + OperandoIzquierdo.valor() + 
                                    "\njnz "  + etiqueta +
                                    "\nmov al, 1"  +                 
                                    "\n" + etiqueta + ":  mov al, 0";    
                break;

      case ">=":RESULT2 = RESULT2 + "\nmov bx, "  + OperandoIzquierdo.valor() + 
                                    "\ncmp bx, "  + OperandoIzquierdo.valor() + 
                                    "\njge "  + etiqueta + 
                                    "\nmov bl, 0"  +     
                                    "\n" + etiqueta+ ":  mov bl, 1";    
                 break;
      case ">": RESULT2 = RESULT2 + "\nmov bx, "  + OperandoIzquierdo.valor() + 
                                    "\ncmp bx, "  + OperandoIzquierdo.valor() + 
                                    "\njg "  + etiqueta + 
                                    "\nmov bl, 0"  +     
                                    "\n" + etiqueta + ":  mov bl, 1";  
                 break;
      case "<=":RESULT2 = RESULT2 + "\nmov bx, "  + OperandoIzquierdo.valor() + 
                                    "\ncmp bx, "  + OperandoIzquierdo.valor() + 
                                    "\njge "  + etiqueta + 
                                    "\nmov bl, 0"  +     
                                    "\n" + etiqueta + ":  mov bl, 1";  
                  break;
      case "<": RESULT2 = RESULT2 + "\nmov bx, "  + OperandoIzquierdo.valor() + 
                                    "\ncmp bx, "  + OperandoIzquierdo.valor() + 
                                    "\njl "  + etiqueta + 
                                    "\nmov bl, 0"  +     
                                    "\n" + etiqueta + ":  mov bl, 1";  
                 break;

      case "!=": RESULT2 = RESULT2 + "\nmov ax, "  + OperandoDerecho.valor() + 
                                    "\ncmp ax, "  + OperandoIzquierdo.valor() + 
                                    "\njnz "  + etiqueta +
                                    "\nmov al, 0"  +                 
                                    "\n" + etiqueta + ":  mov al, 1"; 
                 break;
      case "||": break;
      case "&&":break;
      default: System.err.println("ERROR SEMANTICO: operador "+ Operador.valor()+" requiere solo un operando"); break;
   }
      label_n++;
   
}

public void eval_unary(){}


// FUNCIONES
public void crear_slot_funcion()
{
    pila.Push(new Funcion(""));
}
public void funcion_Insertar(Object nombre)
{
    if(nombre.toString().equals("main"))
    {
        funciones.add(nombre.toString());
        MAIN += "main:\n";
        MAIN += "\tmov ax,datos\n";
        MAIN += "\tmov ds,ax\n";
        MAIN += "\tmov bx,ss\n";
        // HACER TODAS LAS COSAS CON LA PILA SEMENTICA
        Funcion temp = (Funcion) pila.Pop();
        MAIN += temp.valor();

        // VIENE EL CIERRE DEL PROGRAMA
        MAIN += "\ncierre:\n";
        MAIN += "\tmov ah,4ch\n";
        MAIN += "\tmov al,07h\n";
            
        MAIN += "\tint 21h\n\n";
        MAIN += "codigo endS\n";
        MAIN += "end main";

    }
    else{
        funciones.add(nombre.toString());
        FUNCIONES += nombre.toString()+" Proc Near\n";
        
        //HACER TODAS LAS COSAS CON LA PILA SEMANTICA
        Funcion temp = (Funcion) pila.Pop();
        FUNCIONES += temp.valor();
        FUNCIONES += "\tret\n";
        FUNCIONES += nombre.toString()+" endP\n\n";
    }
}
public void generar_llamado_funcion(Object obj)
{
    String temp = ((Funcion)pila.Pop()).valor();
    temp +="\tcall "+obj.toString()+"\n";
    pila.Push(new Funcion(temp));

}
public void revisar_Main()
{
    if(!funciones.contains("main"))
    {
        System.err.println("ERROR SEMANTICO: No se declaro ningun MAIN");
    }
    RESULT += FUNCIONES + MAIN;
}

// REVISAR RETURN
public void revisar_Return()
{
    cont_bucles--;
    if(esReturn && cont_bucles==0)
    {
        System.err.println("ERROR SEMANTICO: No se declaro return en la funcion");
        esReturn = false;
    }
}
public void generar_Return(Object obj)
{
    String temp = ((Funcion)pila.Pop()).valor();
    temp += "\tmov al,"+obj.toString()+"\n";
    pila.Push(new Funcion(temp));
}
// WHILE

public void iniciar_while()
{
    String temp = ((Funcion)pila.Pop()).valor();
    temp += "start_while"+cont_while+":\n";
    pila.Push(new Funcion(temp));
}
public void evaluar_while(Object pri,Object oper,Object seg)
{
    
    String temp = ((Funcion)pila.Pop()).valor();
    temp += "\tCMP "+pri.toString()+","+seg.toString()+"\n";
    
    if(oper.toString().equals("<=")){
        temp+= "\tJLE end_while"+cont_while+"\n";
    }
    else if(oper.toString().equals("=<")){
        temp+= "\tJGE end_while"+cont_while+"\n";    
    }
    else if(oper.toString().equals("!=")){
        temp+= "\tJNE end_while"+cont_while+"\n";    
    }
    else if(oper.toString().equals("==")){
        temp+= "\tJE end_while"+cont_while+"\n";    
    }
    else if(oper.toString().equals("<")){
        temp+= "\tJL end_while"+cont_while+"\n";    
    }
    else if(oper.toString().equals(">")){
        temp+= "\tJG end_while"+cont_while+"\n";    
    }
    else if(oper.toString().equals("||")){
        temp+= "\tJE end_while"+cont_while+"\n";    
    }
    else if(oper.toString().equals("&&")){
        temp+= "\tJNE end_while"+cont_while+"\n";    
    }
    pila.Push(new Funcion(temp));
}
public void evaluar_while_doble_identi(Object pri,Object oper,Object seg)
{
    
    String temp = ((Funcion)pila.Pop()).valor();
    temp += "\tmov al,"+seg.toString()+"\n";
    temp += "\tCMP "+pri.toString()+",al\n";
    
    if(oper.toString().equals("<=")){
        temp+= "\tJLE end_while"+cont_while+"\n";
    }
    else if(oper.toString().equals("=<")){
        temp+= "\tJGE end_while"+cont_while+"\n";    
    }
    else if(oper.toString().equals("!=")){
        temp+= "\tJNE end_while"+cont_while+"\n";    
    }
    else if(oper.toString().equals("==")){
        temp+= "\tJE end_while"+cont_while+"\n";    
    }
    else if(oper.toString().equals("<")){
        temp+= "\tJL end_while"+cont_while+"\n";    
    }
    else if(oper.toString().equals(">")){
        temp+= "\tJG end_while"+cont_while+"\n";    
    }
    else if(oper.toString().equals("||")){
        temp+= "\tJE end_while"+cont_while+"\n";    
    }
    else if(oper.toString().equals("&&")){
        temp+= "\tJNE end_while"+cont_while+"\n";    
    }
    pila.Push(new Funcion(temp));
}

public void evaluar_while_unario(Object pri,Object oper)
{
    String temp = ((Funcion)pila.Pop()).valor();
    temp += "\tCMP "+pri.toString()+",1\n";
    
    if(oper.toString().equals("!")){

        temp+= "\tJNE end_while"+cont_while+"\n";
    }
    else{
        temp+= "\tJE end_while"+cont_while+"\n";
    }
    pila.Push(new Funcion(temp));
}

public void terminar_while()
{
    String temp = ((Funcion)pila.Pop()).valor();
    temp +="\tJMP start_while"+cont_while+"\n";
    temp +="end_while"+cont_while+":\n";
    cont_while++;
    pila.Push(new Funcion(temp));
}

public void revisar_identi(Object pidenti)
{
    if(!identis.contains(pidenti.toString()))
    {
        System.err.println("ERROR SEMANTICO: Identificador => "+pidenti.toString()+" nunca declarado" );
    }
}

public void revisar_funcion(Object obj)
{
    if(!funciones.contains(obj.toString()))
    {
        System.err.println("ERROR SEMANTICO: Funcion => "+obj.toString()+" nunca declarada" );
    }
}

// IF-ELSE
public void iniciar_if()
{
    String temp = ((Funcion)pila.Pop()).valor();
    temp += "start_if"+cont_if+":\n";
    pila.Push(new Funcion(temp));
}
public void terminar_if()
{
    String temp = ((Funcion)pila.Pop()).valor();
    temp +="else"+cont_if+":\n";
    cont_if++;
    pila.Push(new Funcion(temp));
}
public void terminar_if_else()
{
    String temp = ((Funcion)pila.Pop()).valor();
    temp +="\tJMP end_else"+cont_if+"\n";
    temp +="else"+cont_if+":\n";
    pila.Push(new Funcion(temp));
}
public void terminar_else()
{
    String temp = ((Funcion)pila.Pop()).valor();
    temp +="end_else"+cont_if+":\n";
    cont_if++;
    pila.Push(new Funcion(temp));
}

public void evaluar_if(Object pri,Object oper,Object seg)
{
    
    String temp = ((Funcion)pila.Pop()).valor();
    temp += "\tCMP "+pri.toString()+","+seg.toString()+"\n";
    
    if(oper.toString().equals("<=")){
        temp+= "\tJLE else"+cont_if+"\n";
    }
    else if(oper.toString().equals("=<")){
        temp+= "\tJGE else"+cont_if+"\n";    
    }
    else if(oper.toString().equals("!=")){
        temp+= "\tJNE else"+cont_if+"\n";    
    }
    else if(oper.toString().equals("==")){
        temp+= "\tJE else"+cont_if+"\n";    
    }
    else if(oper.toString().equals("<")){
        temp+= "\tJL else"+cont_if+"\n";    
    }
    else if(oper.toString().equals(">")){
        temp+= "\tJG else"+cont_if+"\n";    
    }
    else if(oper.toString().equals("||")){
        temp+= "\tJE else"+cont_if+"\n";    
    }
    else if(oper.toString().equals("&&")){
        temp+= "\tJNE else"+cont_if+"\n";    
    }
    pila.Push(new Funcion(temp));
}
public void evaluar_if_doble_identi(Object pri,Object oper,Object seg)
{
    
    String temp = ((Funcion)pila.Pop()).valor();
    temp += "\tmov al,"+seg.toString()+"\n";
    temp += "\tCMP "+pri.toString()+",al\n";
    
    if(oper.toString().equals("<=")){
        temp+= "\tJLE else"+cont_if+"\n";
    }
    else if(oper.toString().equals("=<")){
        temp+= "\tJGE else"+cont_if+"\n";    
    }
    else if(oper.toString().equals("!=")){
        temp+= "\tJNE else"+cont_if+"\n";    
    }
    else if(oper.toString().equals("==")){
        temp+= "\tJE else"+cont_if+"\n";    
    }
    else if(oper.toString().equals("<")){
        temp+= "\tJL else"+cont_if+"\n";    
    }
    else if(oper.toString().equals(">")){
        temp+= "\tJG else"+cont_if+"\n";    
    }
    else if(oper.toString().equals("||")){
        temp+= "\tJE else"+cont_if+"\n";    
    }
    else if(oper.toString().equals("&&")){
        temp+= "\tJNE else"+cont_if+"\n";    
    }
    pila.Push(new Funcion(temp));
}

public void evaluar_if_unario(Object pri,Object oper)
{
    String temp = ((Funcion)pila.Pop()).valor();
    temp += "\tCMP "+pri.toString()+",1\n";
    
    if(oper.toString().equals("!")){

        temp+= "\tJNE else"+cont_if+"\n";
    }
    else{
        temp+= "\tJE else"+cont_if+"\n";
    }
    pila.Push(new Funcion(temp));
}

public void generar_read(Object obj)
{
    String temp = ((Funcion)pila.Pop()).valor();
    temp+= "\tread\n";
    temp+= "\tmov "+obj.toString()+",al\n";
    pila.Push(new Funcion(temp));       
}
public void generar_read()
{
    String temp = ((Funcion)pila.Pop()).valor();
    temp+= "\tread\n";
    pila.Push(new Funcion(temp));    
}

public void generar_write(Object obj)
{
    String temp = ((Funcion)pila.Pop()).valor();
    temp+= "\twrite "+obj.toString()+"\n";
    pila.Push(new Funcion(temp));    
}

:};

action code {:
	

:};

// PALABRAS RESERVADAS
  terminal BOOLEAN ;//"boolean"                     
  terminal CHAR; //"char"                       
  terminal ELSE; //"else"                         
  terminal INT; //"int"                          
  terminal IF; //"if"                         
  terminal PUBLIC; //"public"                       
  terminal RETURN; //"return"                      
  terminal VOID; //"void"                        
  terminal WHILE; //"while"                       
  terminal FLOAT; // "float"                       
  terminal LONG; // "long"                                              
  terminal SHORT; //"short"                       
  terminal BREAK; //"break"                                              
  terminal CASE; //"case"                       
  terminal CONTINUE; //"continue"                                                   
  terminal DEFAULT; //"default"                        
  terminal DO; //"do"                                                
  terminal FOR; //"for"                       
  terminal SWITCH; //"switch"                                              
  terminal READ; //"read"                                                
  terminal WRITE; //"write"                        

  terminal UNSIGNED ;
  terminal AUTO;
  terminal STATIC;
  terminal ENUM;
  terminal EXTERN;
  terminal GOTO;
  terminal REGISTER;
  terminal SIGNED;
  terminal SIZEOF;
  terminal STRUCT;
  terminal TYPEDEF;
  terminal VOLATILE;
  terminal MAIN;

  // SEPARADORES

  terminal LBRACE; //"{"                            
  terminal RBRACE; //"}"                            
  terminal LBRACK; //"["                            
  terminal RBRACK; //"]"                            
  terminal SEMICOLON; //";"                            
  terminal COMMA; //","                            
  terminal DOT; //"."                            
  terminal NOT; //"!"                            
  terminal QUESTION; // "?"                            
  terminal COLON; //":"                            

 // ARITMETICOS
  terminal PLUS; //"+"                            
  terminal MINUS; //"-"                            
  terminal MULT; //"*"                            
  terminal DIV; //"/"                            
  terminal MOD; //"%"                            
  terminal PLUS_PLUS; //"++"                            
  terminal MINUS_MINUS; //"--"                            
  terminal PLUS_EQ; //"+="                            
  terminal MINUS_EQ; //"-="                            
  terminal MULT_EQ; //"*="                            
  terminal DIV_EQ; // "/=" 
   
terminal GT_GT;//">>"                     
terminal LT_LT;//"<<"                     
terminal TOS;//"~"                      
terminal MOD_EQ;//"%="                     
terminal AT_EQ;//"&="                     
terminal UP_EQ;//"^="                     
terminal OR_EQ;//"|="                     
terminal LT_LT_EQ;//"<<="                    
terminal GT_GT_EQ;//">>="                    
terminal POINTER;//"->"                     
    
  terminal LPAREN; // "("                            
  terminal RPAREN; //")"                            
  terminal EQ; //"="                            
                        
// BOOLEANOS
terminal EQEQ; //  "=="                           
terminal LTEQ; //  "<="                           
terminal GTEQ; // ">="                          
terminal NOTEQ; //  "!="                           
terminal ANDAND; //  "&&"                           
terminal AT; //  "&"          			   
terminal OROR; //  "||"                           
terminal GT; //  ">"                            
terminal LT; //  "<"                            

// IDENTIFICADOR
terminal java.lang.String IDENTIFIER; // name

// LITERALES
terminal java.lang.Number INTEGER_LITERAL;
terminal java.lang.Number FLOATING_POINT_LITERAL;
terminal java.lang.Boolean BOOLEAN_LITERAL;
terminal java.lang.Character CHARACTER_LITERAL;
terminal java.lang.String STRING_LITERAL;

terminal HEX_LITERAL;
terminal OCT_LITERAL;
terminal NULL_LITERAL;

// INICIO
non terminal String estructura;

// ESTRUCTURA
non terminal String statement_globales;
non terminal String statement_funciones;
non terminal String cuerpo_funcion;
non terminal String cuerpo_funcion_aux;
non terminal String llamado_funcion;
non terminal String statement_variables_locales_inicio;
non terminal String statement_variables_locales;

    // IF-ELSE -FOR -WHILE
non terminal String statement_if;
non terminal String statement_while;
non terminal String statement_for;  
non terminal String statement_else;  

    // SWITCH
non terminal String statement_switch ;
non terminal String statement_switch_aux;
non terminal String statement_cuerpo_case;

    // CONTINUE - BREAK - RETURN
non terminal String otras_palabras;
non terminal String return_variables;

// DECLARACIONES
non terminal String declaracion_identificador;
non terminal String varios_identificadores;
non terminal String valor_inicial;

non terminal String declaracion_funciones;
non terminal String varios_tipos;

// LITERALES
non terminal String literal;
non terminal String literal_numerico;

// TIPOS
non terminal String type;

// EXPRESIONES
non terminal String expresiones;
non terminal String expresiones_statement;
non terminal String asignacion;
non terminal String expresion_aritmetica;
non terminal String expresion_aritmetica_unaria;
non terminal String expresion_aritmetica_binaria;
non terminal String expresion_booleana;

non terminal String expresiones_state;  // AYUDA CON EXPRESIONES DE WHILE NUEVO
non terminal String expresiones_state_if;

// OPERADORES
non terminal String operadores_unarios;
non terminal String operadores_binarios;
non terminal String operadores_asignacion;
non terminal String operadores_booleanos;

// READ AND WRITE
non terminal String estructura_read;
non terminal String estructura_read_parametros;

non terminal String estructura_write;
non terminal String estructura_write_parametros;
non terminal String estructura_write_parametros_aux;

// ERROR ****
non terminal String error_semicolon;
non terminal String error_corchete;

// VACIO
non terminal String epsilon;



/* Precedences */
precedence left PLUS, MINUS;
precedence left MULT, DIV, MOD;
precedence left NOT,PLUS_PLUS,MINUS_MINUS;

// GRAMATICA
start with estructura;

estructura ::= 
            statement_globales;            


// PARTE DE GLOBALES
statement_globales ::= 
                declaracion_identificador statement_globales
        |       asignacion SEMICOLON statement_globales 
        |       declaracion_funciones statement_funciones;              // TIENE QUE HABER UNA FUNCION **** LLAMADO A FUNCIONES

// DECLARACION VARIABLES *******************
declaracion_identificador ::=
                type  IDENTIFIER:i  varios_identificadores valor_inicial SEMICOLON {:parser.recuerda_id(i);parser.inserta_TS();:}
        |       error:e{:parser.report_error("Error Sintactico: Declaracion Identificador",e);:} SEMICOLON;

varios_identificadores    ::=
                COMMA  IDENTIFIER:i  varios_identificadores  {:parser.valor_id(null);parser.recuerda_id(i);:}
        |       epsilon;

valor_inicial             ::=
                epsilon {:parser.valor_id(null);:}
        |       EQ expresiones_statement; // antes tenia literal_numerico

// PARTE DE FUNCIONES 
statement_funciones  ::=
                declaracion_funciones statement_funciones
        |       epsilon {:parser.revisar_Main();:};
                

declaracion_funciones ::=
                 type  IDENTIFIER:i {:parser.esReturn= true;parser.cont_bucles++;parser.crear_slot_funcion();:} LPAREN RPAREN cuerpo_funcion           {:parser.funcion_Insertar(i);:}
        |       VOID IDENTIFIER:i {:parser.esReturn= false;parser.cont_bucles++;parser.crear_slot_funcion();:} LPAREN RPAREN cuerpo_funcion                          {:parser.funcion_Insertar(i);:}
        |       error:e{:parser.report_error("Error Sintactico: Statement de Funciones",e);:} RBRACE ; 

varios_tipos            ::=
                COMMA type IDENTIFIER varios_tipos
        |       epsilon;

// CUERPO DE LA FUNCION
cuerpo_funcion          ::=
                LBRACE cuerpo_funcion_aux;                          
                

cuerpo_funcion_aux          ::=
                estructura_read cuerpo_funcion_aux
        |       estructura_write cuerpo_funcion_aux
        |       llamado_funcion cuerpo_funcion_aux
        |       expresiones cuerpo_funcion_aux
        |       statement_if cuerpo_funcion_aux
        |       statement_while cuerpo_funcion_aux
        |       RETURN IDENTIFIER:i  SEMICOLON RBRACE {:parser.revisar_identi(i);parser.esReturn=false;parser.cont_bucles=0;parser.generar_Return(i);:}
        |       RETURN INTEGER_LITERAL:i  SEMICOLON RBRACE {:parser.esReturn=false;parser.cont_bucles=0;parser.generar_Return(i);:}
        |       RBRACE {:parser.revisar_Return();:};     // SE TERMINA LA FUNCION    



// IF_ELSE **************

statement_if ::=
                IF {:parser.cont_bucles++;parser.iniciar_if();:}LPAREN expresiones_state_if RPAREN LBRACE cuerpo_funcion_aux statement_else
        |       IF error:e{:parser.report_error("Error Sintactico: Statement en IF",e);:} RBRACE;

statement_else ::=
     {:parser.terminar_if();:}   |        ELSE {:parser.cont_bucles++;parser.terminar_if_else();:} LBRACE cuerpo_funcion_aux {:parser.terminar_else();:};

// WHILE

statement_while ::=
                WHILE {:parser.cont_bucles++;parser.iniciar_while();:} LPAREN expresiones_state RPAREN LBRACE cuerpo_funcion_aux {:parser.terminar_while();:}
        |       WHILE error:e{:parser.report_error("Error Sintactico: Statement en WHILE",e);:} RBRACE ;
// FOR

statement_for   ::=
                FOR LPAREN expresiones_statement SEMICOLON expresiones_statement SEMICOLON expresiones_statement RPAREN LBRACE cuerpo_funcion_aux
        |       FOR error:e{:parser.report_error("Error Sintactico: Statement en FOR",e);:} RBRACE ;

// SWITCH *****************

statement_switch    ::=
                SWITCH LPAREN expresiones_statement RPAREN LBRACE statement_switch_aux RBRACE
        |       SWITCH error:e{:parser.report_error("Error Sintactico: Statement en SWITCH",e);:} RBRACE ;

statement_switch_aux     ::=
        |        CASE INTEGER_LITERAL COLON statement_cuerpo_case statement_switch_aux
        |       DEFAULT COLON statement_cuerpo_case statement_switch_aux
        |       CASE error:e{:parser.report_error("Error Sintactico: Statement en CASE",e);:} SEMICOLON 
        |       DEFAULT error:e{:parser.report_error("Error Sintactico: Statement en DEFAULT",e);:} SEMICOLON ;

statement_cuerpo_case         ::=
                estructura_read statement_cuerpo_case
        |       estructura_write statement_cuerpo_case
        |       llamado_funcion statement_cuerpo_case
        |       expresiones statement_cuerpo_case
        |       BREAK SEMICOLON;     // SE TERMINA LA FUNCION  

// CONTINUES, BREAK AND RETURN

otras_palabras  ::=
                CONTINUE SEMICOLON
        |       BREAK   SEMICOLON
        |       RETURN return_variables  SEMICOLON;

return_variables    ::=
                    
        |       literal
        |       IDENTIFIER;

// VARIABLES LOCALES DE FUNCION ******************
statement_variables_locales_inicio ::=
        |       epsilon
                statement_variables_locales;

statement_variables_locales ::=
                declaracion_identificador 
        |       declaracion_identificador statement_variables_locales;  

// OPERADPRES *********************

operadores_unarios ::=
                PLUS_PLUS
        |       MINUS_MINUS;


operadores_binarios ::=
                PLUS:o {:parser.operador(o);:}
        |       MINUS:o {:parser.operador(o);:}
        |       MULT:o {:parser.operador(o);:}
        |       DIV:o {:parser.operador(o);:}
        |       MOD:o {:parser.operador(o);:};

operadores_asignacion ::= 
                EQ:o {:parser.operador(o);:}
        |       PLUS_EQ:o {:parser.operador(o);:}
        |       MINUS_EQ:o {:parser.operador(o);:}
        |       MULT_EQ:o {:parser.operador(o);:}
        |       DIV_EQ:o {:parser.operador(o);:};   


operadores_booleanos ::= 
                OROR:o {:parser.operador(o);:}
        |       ANDAND:o {:parser.operador(o);:}
        |       EQEQ:o {:parser.operador(o);:}
        |       GTEQ:o {:parser.operador(o);:}
        |       GT:o {:parser.operador(o);:}
        |       LTEQ:o {:parser.operador(o);:}
        |       LT:o {:parser.operador(o);:}
        |       NOTEQ:o {:parser.operador(o);:};   

// LITERALES *************************

literal ::=
		INTEGER_LITERAL 
	|	FLOATING_POINT_LITERAL
	|	BOOLEAN_LITERAL 
	|	CHARACTER_LITERAL 
	|	STRING_LITERAL 
        |       HEX_LITERAL
        |       OCT_LITERAL
	|	NULL_LITERAL;

literal_numerico ::=
		INTEGER_LITERAL:v {:parser.valor_id(v);:}
	|	FLOATING_POINT_LITERAL:v {:parser.valor_id(v);:}
        |       HEX_LITERAL:v {:parser.valor_id(v);:}
        |       OCT_LITERAL:v {:parser.valor_id(v);:};

// TIPOS *****************
type	::=
		BOOLEAN
	|	INT
	|	CHAR
	|	FLOAT
        |       LONG
        |       SHORT;




// READ AND WRITE **************

estructura_read    ::=
                READ LPAREN  RPAREN SEMICOLON {:parser.generar_read();:}
        |       READ LPAREN  IDENTIFIER:i RPAREN SEMICOLON {:parser.generar_read(i);:}
        |       READ  error:e{:parser.report_error("Error Sintactico: Uso de READ",e);:}  SEMICOLON ;

estructura_read_parametros  ::=
               ; 

estructura_write   ::=
                WRITE LPAREN  estructura_write_parametros_aux RPAREN SEMICOLON
        |       WRITE error:e{:parser.report_error("Error Sintactico: Uso de WRITE",e);:} SEMICOLON ;
                
estructura_write_parametros   ::=
                estructura_write_parametros_aux
        |       estructura_write_parametros_aux COMMA estructura_write_parametros;       

estructura_write_parametros_aux   ::=
                 IDENTIFIER:i {:parser.generar_write(i);:}
         |       INTEGER_LITERAL:i {:parser.generar_write(i);:};

// LLAMADO A FUNCION ********
llamado_funcion             ::=
                IDENTIFIER:i LPAREN  RPAREN SEMICOLON {:parser.revisar_funcion(i);parser.generar_llamado_funcion(i);:}
        |       IDENTIFIER error:e{:parser.report_error("Error Sintactico: LLAMADO DE FUNCION",e);:} SEMICOLON ;
               

//      EXPRESIONES
expresiones   ::= 
                  expresiones_statement SEMICOLON;

 
expresiones_statement ::=
                asignacion
        |       expresion_aritmetica  
        |       expresion_booleana ;

asignacion ::= 
                IDENTIFIER:i {:parser.identificador(i);:} operadores_asignacion expresiones_statement {:parser.evaluar_binario();:};   


expresion_aritmetica ::= 
                 expresion_aritmetica_unaria
        |        expresion_aritmetica_binaria
        |        LPAREN expresion_aritmetica RPAREN
        |        IDENTIFIER:i {:parser.identificador(i);:}
        |        literal_numerico; //antes tenia solo literal

expresion_aritmetica_unaria ::= 
                 operadores_unarios IDENTIFIER 
        |        IDENTIFIER operadores_unarios 
        |        MINUS literal_numerico
        |        MINUS IDENTIFIER;

expresion_aritmetica_binaria ::= 
                 expresion_aritmetica operadores_binarios expresion_aritmetica {:parser.evaluar_binario();:};
        

expresion_booleana ::= 
                  expresion_aritmetica operadores_booleanos expresion_aritmetica {:parser.evaluar_binario();:}
          |       NOT expresion_aritmetica
          |       LPAREN expresion_booleana RPAREN;


expresiones_state  ::=
                  INTEGER_LITERAL:i EQEQ:o INTEGER_LITERAL:e {:parser.evaluar_while(i,o,e);:}
          |       INTEGER_LITERAL:i EQEQ:o IDENTIFIER:e      {:parser.revisar_identi(e);parser.evaluar_while(i,o,e);:} 
          |       IDENTIFIER:i      EQEQ:o INTEGER_LITERAL:e {:parser.revisar_identi(i);parser.evaluar_while(i,o,e);:}
          |       IDENTIFIER:i      EQEQ:o IDENTIFIER:e      {:parser.revisar_identi(i);parser.revisar_identi(e);parser.evaluar_while_doble_identi(i,o,e);:}

          |       INTEGER_LITERAL:i LTEQ:o INTEGER_LITERAL:e {:parser.evaluar_while(i,o,e);:}
          |       INTEGER_LITERAL:i LTEQ:o IDENTIFIER:e      {:parser.revisar_identi(e);parser.evaluar_while(i,o,e);:} 
          |       IDENTIFIER:i      LTEQ:o INTEGER_LITERAL:e {:parser.revisar_identi(i);parser.evaluar_while(i,o,e);:}
          |       IDENTIFIER:i      LTEQ:o IDENTIFIER:e      {:parser.revisar_identi(i);parser.revisar_identi(e);parser.evaluar_while_doble_identi(i,o,e);:}

          |       INTEGER_LITERAL:i GTEQ:o INTEGER_LITERAL:e {:parser.evaluar_while(i,o,e);:}
          |       INTEGER_LITERAL:i GTEQ:o IDENTIFIER:e      {:parser.revisar_identi(e);parser.evaluar_while(i,o,e);:} 
          |       IDENTIFIER:i      GTEQ:o INTEGER_LITERAL:e {:parser.revisar_identi(i);parser.evaluar_while(i,o,e);:}
          |       IDENTIFIER:i      GTEQ:o IDENTIFIER:e      {:parser.revisar_identi(i);parser.revisar_identi(e);parser.evaluar_while_doble_identi(i,o,e);:}

          |       INTEGER_LITERAL:i NOTEQ:o INTEGER_LITERAL:e {:parser.evaluar_while(i,o,e);:}
          |       INTEGER_LITERAL:i NOTEQ:o IDENTIFIER:e      {:parser.revisar_identi(e);parser.evaluar_while(i,o,e);:} 
          |       IDENTIFIER:i      NOTEQ:o INTEGER_LITERAL:e {:parser.revisar_identi(i);parser.evaluar_while(i,o,e);:}
          |       IDENTIFIER:i      NOTEQ:o IDENTIFIER:e      {:parser.revisar_identi(i);parser.revisar_identi(e);parser.evaluar_while_doble_identi(i,o,e);:}

          |       INTEGER_LITERAL:i ANDAND:o INTEGER_LITERAL:e {:parser.evaluar_while(i,o,e);:}
          |       INTEGER_LITERAL:i ANDAND:o IDENTIFIER:e      {:parser.revisar_identi(e);parser.evaluar_while(i,o,e);:} 
          |       IDENTIFIER:i      ANDAND:o INTEGER_LITERAL:e {:parser.revisar_identi(i);parser.evaluar_while(i,o,e);:}
          |       IDENTIFIER:i      ANDAND:o IDENTIFIER:e      {:parser.revisar_identi(i);parser.revisar_identi(e);parser.evaluar_while_doble_identi(i,o,e);:}

          |       INTEGER_LITERAL:i OROR:o INTEGER_LITERAL:e {:parser.evaluar_while(i,o,e);:}
          |       INTEGER_LITERAL:i OROR:o IDENTIFIER:e      {:parser.revisar_identi(e);parser.evaluar_while(i,o,e);:} 
          |       IDENTIFIER:i      OROR:o INTEGER_LITERAL:e {:parser.revisar_identi(i);parser.evaluar_while(i,o,e);:}
          |       IDENTIFIER:i      OROR:o IDENTIFIER:e      {:parser.revisar_identi(i);parser.revisar_identi(e);parser.evaluar_while_doble_identi(i,o,e);:}

          |       INTEGER_LITERAL:i GT:o INTEGER_LITERAL:e {:parser.evaluar_while(i,o,e);:}
          |       INTEGER_LITERAL:i GT:o IDENTIFIER:e      {:parser.revisar_identi(e);parser.evaluar_while(i,o,e);:} 
          |       IDENTIFIER:i      GT:o INTEGER_LITERAL:e {:parser.revisar_identi(i);parser.evaluar_while(i,o,e);:}
          |       IDENTIFIER:i      GT:o IDENTIFIER:e      {:parser.revisar_identi(i);parser.revisar_identi(e);parser.evaluar_while_doble_identi(i,o,e);:}

          |       INTEGER_LITERAL:i LT:o INTEGER_LITERAL:e {:parser.evaluar_while(i,o,e);:}
          |       INTEGER_LITERAL:i LT:o IDENTIFIER:e      {:parser.revisar_identi(e);parser.evaluar_while(i,o,e);:} 
          |       IDENTIFIER:i      LT:o INTEGER_LITERAL:e {:parser.revisar_identi(i);parser.evaluar_while(i,o,e);:}
          |       IDENTIFIER:i      LT:o IDENTIFIER:e      {:parser.revisar_identi(i);parser.revisar_identi(e);parser.evaluar_while_doble_identi(i,o,e);:}
                 
          |       NOT:o IDENTIFIER:i                          {:parser.revisar_identi(i);parser.evaluar_while_unario(i,o);:}
          |       NOT:o INTEGER_LITERAL:i                     {:parser.evaluar_while_unario(i,o);:}
          
          |       IDENTIFIER:i                              {:parser.revisar_identi(i);parser.evaluar_while_unario(i,"n");:}
          |       INTEGER_LITERAL:i                         {:parser.evaluar_while_unario(i,"n");:}
                ;                          
                        
 expresiones_state_if  ::=
                  INTEGER_LITERAL:i EQEQ:o INTEGER_LITERAL:e {:parser.evaluar_if(i,o,e);:}
          |       INTEGER_LITERAL:i EQEQ:o IDENTIFIER:e      {:parser.revisar_identi(e);parser.evaluar_if(i,o,e);:} 
          |       IDENTIFIER:i      EQEQ:o INTEGER_LITERAL:e {:parser.revisar_identi(i);parser.evaluar_if(i,o,e);:}
          |       IDENTIFIER:i      EQEQ:o IDENTIFIER:e      {:parser.revisar_identi(i);parser.revisar_identi(e);parser.evaluar_if_doble_identi(i,o,e);:}

          |       INTEGER_LITERAL:i LTEQ:o INTEGER_LITERAL:e {:parser.evaluar_if(i,o,e);:}
          |       INTEGER_LITERAL:i LTEQ:o IDENTIFIER:e      {:parser.revisar_identi(e);parser.evaluar_if(i,o,e);:} 
          |       IDENTIFIER:i      LTEQ:o INTEGER_LITERAL:e {:parser.revisar_identi(i);parser.evaluar_if(i,o,e);:}
          |       IDENTIFIER:i      LTEQ:o IDENTIFIER:e      {:parser.revisar_identi(i);parser.revisar_identi(e);parser.evaluar_if_doble_identi(i,o,e);:}

          |       INTEGER_LITERAL:i GTEQ:o INTEGER_LITERAL:e {:parser.evaluar_if(i,o,e);:}
          |       INTEGER_LITERAL:i GTEQ:o IDENTIFIER:e      {:parser.revisar_identi(e);parser.evaluar_if(i,o,e);:} 
          |       IDENTIFIER:i      GTEQ:o INTEGER_LITERAL:e {:parser.revisar_identi(i);parser.evaluar_if(i,o,e);:}
          |       IDENTIFIER:i      GTEQ:o IDENTIFIER:e      {:parser.revisar_identi(i);parser.revisar_identi(e);parser.evaluar_if_doble_identi(i,o,e);:}

          |       INTEGER_LITERAL:i NOTEQ:o INTEGER_LITERAL:e {:parser.evaluar_if(i,o,e);:}
          |       INTEGER_LITERAL:i NOTEQ:o IDENTIFIER:e      {:parser.revisar_identi(e);parser.evaluar_if(i,o,e);:} 
          |       IDENTIFIER:i      NOTEQ:o INTEGER_LITERAL:e {:parser.revisar_identi(i);parser.evaluar_if(i,o,e);:}
          |       IDENTIFIER:i      NOTEQ:o IDENTIFIER:e      {:parser.revisar_identi(i);parser.revisar_identi(e);parser.evaluar_if_doble_identi(i,o,e);:}

          |       INTEGER_LITERAL:i ANDAND:o INTEGER_LITERAL:e {:parser.evaluar_if(i,o,e);:}
          |       INTEGER_LITERAL:i ANDAND:o IDENTIFIER:e      {:parser.revisar_identi(e);parser.evaluar_if(i,o,e);:} 
          |       IDENTIFIER:i      ANDAND:o INTEGER_LITERAL:e {:parser.revisar_identi(i);parser.evaluar_if(i,o,e);:}
          |       IDENTIFIER:i      ANDAND:o IDENTIFIER:e      {:parser.revisar_identi(i);parser.revisar_identi(e);parser.evaluar_if_doble_identi(i,o,e);:}

          |       INTEGER_LITERAL:i OROR:o INTEGER_LITERAL:e {:parser.evaluar_if(i,o,e);:}
          |       INTEGER_LITERAL:i OROR:o IDENTIFIER:e      {:parser.revisar_identi(e);parser.evaluar_if(i,o,e);:} 
          |       IDENTIFIER:i      OROR:o INTEGER_LITERAL:e {:parser.revisar_identi(i);parser.evaluar_if(i,o,e);:}
          |       IDENTIFIER:i      OROR:o IDENTIFIER:e      {:parser.revisar_identi(i);parser.revisar_identi(e);parser.evaluar_if_doble_identi(i,o,e);:}

          |       INTEGER_LITERAL:i GT:o INTEGER_LITERAL:e {:parser.evaluar_if(i,o,e);:}
          |       INTEGER_LITERAL:i GT:o IDENTIFIER:e      {:parser.revisar_identi(e);parser.evaluar_if(i,o,e);:} 
          |       IDENTIFIER:i      GT:o INTEGER_LITERAL:e {:parser.revisar_identi(i);parser.evaluar_if(i,o,e);:}
          |       IDENTIFIER:i      GT:o IDENTIFIER:e      {:parser.revisar_identi(i);parser.revisar_identi(e);parser.evaluar_if_doble_identi(i,o,e);:}

          |       INTEGER_LITERAL:i LT:o INTEGER_LITERAL:e {:parser.evaluar_if(i,o,e);:}
          |       INTEGER_LITERAL:i LT:o IDENTIFIER:e      {:parser.revisar_identi(e);parser.evaluar_if(i,o,e);:} 
          |       IDENTIFIER:i      LT:o INTEGER_LITERAL:e {:parser.revisar_identi(i);parser.evaluar_if(i,o,e);:}
          |       IDENTIFIER:i      LT:o IDENTIFIER:e      {:parser.revisar_identi(i);parser.revisar_identi(e);parser.evaluar_if_doble_identi(i,o,e);:}
                 
          |       NOT:o IDENTIFIER:i                          {:parser.revisar_identi(i);parser.evaluar_if_unario(i,o);:}
          |       NOT:o INTEGER_LITERAL:i                     {:parser.evaluar_if_unario(i,o);:}
          
          |       IDENTIFIER:i                              {:parser.revisar_identi(i);parser.evaluar_if_unario(i,"n");:}
          |       INTEGER_LITERAL:i                         {:parser.evaluar_if_unario(i,"n");:}
                ;                                              
                                 			   
                                                   

// ********** VACIO
epsilon ::= /*nothing */;
        


