import java_cup.runtime.*;
import java.io.*;
import java.util.*;




parser code  {: 

  public static analizador_lexico.Scanner s;
  public static int errors = 0;
  public static int warnings = 0;
  
  public static void main(String argv[]) {

    for (int i = 0; i < argv.length; i++) {
      try {
        
        System.out.println("\n...Creating Symbol-Table for ["+argv[i]+"]...\n");
	  s = new analizador_lexico.Scanner(new FileReader(argv[i]));
        Parser p = new Parser(s);
        p.parse();

       

      }
      catch (Exception e) {
        e.printStackTrace(System.out);
        System.exit(1);
      }
    }
  }


  public void report_error(String message, Object info) {
    if (info instanceof String){
	errors++; 
      System.err.println("  "+ errors + "==> " + info + " "+ message + 
					"\n       Parsing resumed from 2nd token before" + s.current_lexeme()+"\n");
    }
    else {
    	StringBuffer m = new StringBuffer("Error ");
    	if (info instanceof java_cup.runtime.Symbol) 
     	   m.append( "("+info.toString()+")" );     
    	m.append(" : "+message);   
    	System.err.println(m);
    }
  }

  public void sem_error(String lexeme, String message) {
	errors++;
     	System.err.println("Error "+ s.current_lexeme() + " : Semantic error");
      System.err.println("  "+ errors + "==> " + message + ": "+ lexeme + "\n");
  }

  public void warning(String lexeme, String message) {
	warnings++;
     	System.err.println("Warning "+ s.current_lexeme());
      System.err.println("  "+ warnings + "==> " + message + ": "+ lexeme + "\n");
  } 
  
  public void report_fatal_error(String message, Object info) {
    	report_error(message, info);
    	throw new RuntimeException("Fatal Syntax Error");
  }
:};

action code {:
	

:};

// PALABRAS RESERVADAS
  terminal BOOLEAN ;//"boolean"                     
  terminal CHAR; //"char"                       
  terminal ELSE; //"else"                         
  terminal INT; //"int"                          
  terminal IF; //"if"                         
  terminal PUBLIC; //"public"                       
  terminal RETURN; //"return"                      
  terminal VOID; //"void"                        
  terminal WHILE; //"while"                       
  terminal FLOAT; // "float"                       
  terminal LONG; // "long"                                              
  terminal SHORT; //"short"                       
  terminal BREAK; //"break"                                              
  terminal CASE; //"case"                       
  terminal CONTINUE; //"continue"                                                   
  terminal DEFAULT; //"default"                        
  terminal DO; //"do"                                                
  terminal FOR; //"for"                       
  terminal SWITCH; //"switch"                                              
  terminal READ; //"read"                                                
  terminal WRITE; //"write"                        

  terminal UNSIGNED ;
  terminal AUTO;
  terminal STATIC;
  terminal ENUM;
  terminal EXTERN;
  terminal GOTO;
  terminal REGISTER;
  terminal SIGNED;
  terminal SIZEOF;
  terminal STRUCT;
  terminal TYPEDEF;
  terminal VOLATILE;
  terminal MAIN;

  // SEPARADORES

  terminal LBRACE; //"{"                            
  terminal RBRACE; //"}"                            
  terminal LBRACK; //"["                            
  terminal RBRACK; //"]"                            
  terminal SEMICOLON; //";"                            
  terminal COMMA; //","                            
  terminal DOT; //"."                            
  terminal NOT; //"!"                            
  terminal QUESTION; // "?"                            
  terminal COLON; //":"                            

 // ARITMETICOS
  terminal PLUS; //"+"                            
  terminal MINUS; //"-"                            
  terminal MULT; //"*"                            
  terminal DIV; //"/"                            
  terminal MOD; //"%"                            
  terminal PLUS_PLUS; //"++"                            
  terminal MINUS_MINUS; //"--"                            
  terminal PLUS_EQ; //"+="                            
  terminal MINUS_EQ; //"-="                            
  terminal MULT_EQ; //"*="                            
  terminal DIV_EQ; // "/=" 
   
terminal GT_GT;//">>"                     
terminal LT_LT;//"<<"                     
terminal TOS;//"~"                      
terminal MOD_EQ;//"%="                     
terminal AT_EQ;//"&="                     
terminal UP_EQ;//"^="                     
terminal OR_EQ;//"|="                     
terminal LT_LT_EQ;//"<<="                    
terminal GT_GT_EQ;//">>="                    
terminal POINTER;//"->"                     
    
  terminal LPAREN; // "("                            
  terminal RPAREN; //")"                            
  terminal EQ; //"="                            
                        
// BOOLEANOS
terminal EQEQ; //  "=="                           
terminal LTEQ; //  "<="                           
terminal GTEQ; // ">="                          
terminal NOTEQ; //  "!="                           
terminal ANDAND; //  "&&"                           
terminal AT; //  "&"          			   
terminal OROR; //  "||"                           
terminal GT; //  ">"                            
terminal LT; //  "<"                            

// IDENTIFICADOR
terminal java.lang.String IDENTIFIER; // name

// LITERALES
terminal java.lang.Number INTEGER_LITERAL;
terminal java.lang.Number FLOATING_POINT_LITERAL;
terminal java.lang.Boolean BOOLEAN_LITERAL;
terminal java.lang.Character CHARACTER_LITERAL;
terminal java.lang.String STRING_LITERAL;

terminal HEX_LITERAL;
terminal OCT_LITERAL;
terminal NULL_LITERAL;


// INICIO
non terminal estructura;

// ESTRUCTURA
non terminal statement_globales;
non terminal statement_funciones;

// LITERALES
non terminal literal;

// TIPOS
non terminal type;
non terminal primitive_type;
non terminal numeric_type;



// VACIO
non terminal epsilon;


// GRAMATICA
start with estructura;

estructura ::= 
            statement_globales
        |   statement_funciones
        |   epsilon;

// LITERALES *************************

literal ::=
		INTEGER_LITERAL 
	|	FLOATING_POINT_LITERAL
	|	BOOLEAN_LITERAL 
	|	CHARACTER_LITERAL 
	|	STRING_LITERAL 
        |       HEX_LITERAL
        |       OCT_LITERAL
	|	NULL_LITERAL;


// TIPOS *****************
type	::=
		primitive_type
	|	IDENTIFIER;
primitive_type ::=
		numeric_type
	|	BOOLEAN;
numeric_type ::= 
		INT
	|	CHAR
	|	FLOAT
        |       LONG
        |       SHORT;

// EXPRESIONES **************


/*
// PARTE DE GLOBALES
statement_globales ::= literal;

// PARTE DE FUNCIONES
statement_funciones ::= literal;
*/

// ********** VACIO
epsilon ::= /*nothing */;
