

import java_cup.runtime.*;
import java.io.*;
import java.util.*;




parser code  {: 
  public static int errors = 0;
  public static int warnings = 0;
  public static analizador_lexico.Scanner s;
  


  public static void main(String argv[]) {

    for (int i = 0; i < argv.length; i++) {
      try {
	  s = new analizador_lexico.Scanner(new FileReader(argv[i]));
        Parser p = new Parser(s);
        p.parse();
        System.out.println("Number of errors = " + errors + ".");
       

      }
      catch (Exception e) {
        e.printStackTrace(System.out);
        System.exit(1);
      }
    }
  }
    protected int error_sync_size () {
        //System.out.println(":error_sync_size was called.");
        return 1; // not recommended by the CUP manual
}
  public void report_error(String message, Object info) {
    if (info instanceof String){
	errors++; 
      System.err.println("  "+ errors + "==> " + info + " "+ message + 
					"\n       Parsing resumed from 2nd token before" + s.current_lexeme()+"\n");
    }
    else {
    	StringBuffer m = new StringBuffer("Error ");
    	if (info instanceof java_cup.runtime.Symbol) 
     	   m.append( "("+info.toString()+")" );     
    	m.append(" : "+message);   
    	System.err.println(m);
    }
  }
   
  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    throw new RuntimeException("Fatal Syntax Error");
  }


:};

action code {:
	

:};

// PALABRAS RESERVADAS
  terminal BOOLEAN ;//"boolean"                     
  terminal CHAR; //"char"                       
  terminal ELSE; //"else"                         
  terminal INT; //"int"                          
  terminal IF; //"if"                         
  terminal PUBLIC; //"public"                       
  terminal RETURN; //"return"                      
  terminal VOID; //"void"                        
  terminal WHILE; //"while"                       
  terminal FLOAT; // "float"                       
  terminal LONG; // "long"                                              
  terminal SHORT; //"short"                       
  terminal BREAK; //"break"                                              
  terminal CASE; //"case"                       
  terminal CONTINUE; //"continue"                                                   
  terminal DEFAULT; //"default"                        
  terminal DO; //"do"                                                
  terminal FOR; //"for"                       
  terminal SWITCH; //"switch"                                              
  terminal READ; //"read"                                                
  terminal WRITE; //"write"                        

  terminal UNSIGNED ;
  terminal AUTO;
  terminal STATIC;
  terminal ENUM;
  terminal EXTERN;
  terminal GOTO;
  terminal REGISTER;
  terminal SIGNED;
  terminal SIZEOF;
  terminal STRUCT;
  terminal TYPEDEF;
  terminal VOLATILE;
  terminal MAIN;
  

  // SEPARADORES

  terminal LBRACE; //"{"                            
  terminal RBRACE; //"}"                            
  terminal LBRACK; //"["                            
  terminal RBRACK; //"]"                            
  terminal SEMICOLON; //";"                            
  terminal COMMA; //","                            
  terminal DOT; //"."                            
  terminal NOT; //"!"                            
  terminal QUESTION; // "?"                            
  terminal COLON; //":"                            

 // ARITMETICOS
  terminal PLUS; //"+"                            
  terminal MINUS; //"-"                            
  terminal MULT; //"*"                            
  terminal DIV; //"/"                            
  terminal MOD; //"%"                            
  terminal PLUS_PLUS; //"++"                            
  terminal MINUS_MINUS; //"--"                            
  terminal PLUS_EQ; //"+="                            
  terminal MINUS_EQ; //"-="                            
  terminal MULT_EQ; //"*="                            
  terminal DIV_EQ; // "/=" 
   
terminal GT_GT;//">>"                     
terminal LT_LT;//"<<"                     
terminal TOS;//"~"                      
terminal MOD_EQ;//"%="                     
terminal AT_EQ;//"&="                     
terminal UP_EQ;//"^="                     
terminal OR_EQ;//"|="                     
terminal LT_LT_EQ;//"<<="                    
terminal GT_GT_EQ;//">>="                    
terminal POINTER;//"->"                     
    
  terminal LPAREN; // "("                            
  terminal RPAREN; //")"                            
  terminal EQ; //"="                            
                        
// BOOLEANOS
terminal EQEQ; //  "=="                           
terminal LTEQ; //  "<="                           
terminal GTEQ; // ">="                          
terminal NOTEQ; //  "!="                           
terminal ANDAND; //  "&&"                           
terminal AT; //  "&"          			   
terminal OROR; //  "||"                           
terminal GT; //  ">"                            
terminal LT; //  "<"                            

// IDENTIFICADOR
terminal java.lang.String IDENTIFIER; // name

// LITERALES
terminal java.lang.Number INTEGER_LITERAL;
terminal java.lang.Number FLOATING_POINT_LITERAL;
terminal java.lang.Boolean BOOLEAN_LITERAL;
terminal java.lang.Character CHARACTER_LITERAL;
terminal java.lang.String STRING_LITERAL;

terminal HEX_LITERAL;
terminal OCT_LITERAL;
terminal NULL_LITERAL;

// INICIO
non terminal String estructura;

// ESTRUCTURA
non terminal String statement_globales;
non terminal String statement_funciones;
non terminal String cuerpo_funcion;
non terminal String cuerpo_funcion_aux;
non terminal String llamado_funcion;
non terminal String statement_variables_locales_inicio;
non terminal String statement_variables_locales;

    // IF-ELSE -FOR -WHILE
non terminal String statement_if;
non terminal String statement_while;
non terminal String statement_for;  
non terminal String statement_else;  

    // SWITCH
non terminal String statement_switch ;
non terminal String statement_switch_aux;
non terminal String statement_cuerpo_case;

    // CONTINUE - BREAK - RETURN
non terminal String otras_palabras;
non terminal String return_variables;

// DECLARACIONES
non terminal String declaracion_identificador;
non terminal String varios_identificadores;
non terminal String valor_inicial;

non terminal String declaracion_funciones;
non terminal String varios_tipos;

// LITERALES
non terminal String literal;
non terminal String literal_numerico;

// TIPOS
non terminal String type;

// EXPRESIONES
non terminal String expresiones;
non terminal String expresiones_statement;
non terminal String asignacion;
non terminal String expresion_aritmetica;
non terminal String expresion_aritmetica_unaria;
non terminal String expresion_aritmetica_binaria;
non terminal String expresion_booleana;


// OPERADORES
non terminal String operadores_unarios;
non terminal String operadores_binarios;
non terminal String operadores_asignacion;
non terminal String operadores_booleanos;

// READ AND WRITE
non terminal String estructura_read;
non terminal String estructura_read_parametros;

non terminal String estructura_write;
non terminal String estructura_write_parametros;
non terminal String estructura_write_parametros_aux;

// ERROR ****
non terminal String error_semicolon;
non terminal String error_corchete;

// VACIO
non terminal String epsilon;



/* Precedences */
precedence left PLUS, MINUS;
precedence left MULT, DIV, MOD;
precedence left NOT,PLUS_PLUS,MINUS_MINUS;

// GRAMATICA
start with estructura;

estructura ::= 
            statement_globales;            


// PARTE DE GLOBALES
statement_globales ::= 
                declaracion_identificador statement_globales
        |       declaracion_funciones statement_funciones;              // TIENE QUE HABER UNA FUNCION **** LLAMADO A FUNCIONES

// DECLARACION VARIABLES *******************
declaracion_identificador ::=
                type IDENTIFIER varios_identificadores valor_inicial SEMICOLON 
        |       error:e{:parser.report_error("Error Semantico: Declaracion Identificador",e);:} SEMICOLON;

varios_identificadores    ::=
                COMMA IDENTIFIER varios_identificadores
        |       epsilon;

valor_inicial             ::=
                EQ expresiones_statement
        |       epsilon;

// PARTE DE FUNCIONES 
statement_funciones  ::=
                declaracion_funciones statement_funciones
        |       epsilon;
                

declaracion_funciones ::=
                type IDENTIFIER LPAREN type IDENTIFIER varios_tipos RPAREN cuerpo_funcion
        |       type IDENTIFIER LPAREN RPAREN cuerpo_funcion
        |       VOID IDENTIFIER LPAREN type IDENTIFIER varios_tipos RPAREN cuerpo_funcion
        |       VOID IDENTIFIER LPAREN RPAREN cuerpo_funcion
        |       error:e{:parser.report_error("Error Semantico: Statement de Funciones",e);:} RBRACE ; 

varios_tipos            ::=
                COMMA type IDENTIFIER varios_tipos
        |       epsilon;

// CUERPO DE LA FUNCION
cuerpo_funcion          ::=
                LBRACE
                
                statement_variables_locales_inicio
                cuerpo_funcion_aux;            //*********************** PROBLEMA AQUI;                
                

cuerpo_funcion_aux          ::=
                estructura_read cuerpo_funcion_aux
        |       estructura_write cuerpo_funcion_aux
        |       llamado_funcion cuerpo_funcion_aux
        |       expresiones cuerpo_funcion_aux
        |       statement_if cuerpo_funcion_aux
        |       statement_while cuerpo_funcion_aux
        |       statement_for cuerpo_funcion_aux
        |       statement_switch cuerpo_funcion_aux
        |       otras_palabras   cuerpo_funcion_aux
        |       RBRACE;     // SE TERMINA LA FUNCION    


// IF_ELSE **************

statement_if ::=
                IF LPAREN expresiones_statement RPAREN LBRACE cuerpo_funcion_aux statement_else
        |       IF error:e{:parser.report_error("Error Semantico: Statement en IF",e);:} RBRACE;

statement_else ::=
        |        ELSE LBRACE cuerpo_funcion_aux;

// WHILE

statement_while ::=
                WHILE LPAREN expresiones_statement RPAREN LBRACE cuerpo_funcion_aux
        |       WHILE error:e{:parser.report_error("Error Semantico: Statement en WHILE",e);:} RBRACE ;
// FOR

statement_for   ::=
                FOR LPAREN expresiones_statement SEMICOLON expresiones_statement SEMICOLON expresiones_statement RPAREN LBRACE cuerpo_funcion_aux
        |       FOR error:e{:parser.report_error("Error Semantico: Statement en FOR",e);:} RBRACE ;

// SWITCH *****************

statement_switch    ::=
                SWITCH LPAREN expresiones_statement RPAREN LBRACE statement_switch_aux RBRACE
        |       SWITCH error:e{:parser.report_error("Error Semantico: Statement en SWITCH",e);:} RBRACE ;

statement_switch_aux     ::=
        |        CASE INTEGER_LITERAL COLON statement_cuerpo_case statement_switch_aux
        |       DEFAULT COLON statement_cuerpo_case statement_switch_aux
        |       CASE error:e{:parser.report_error("Error Semantico: Statement en CASE",e);:} SEMICOLON 
        |       DEFAULT error:e{:parser.report_error("Error Semantico: Statement en DEFAULT",e);:} SEMICOLON ;

statement_cuerpo_case         ::=
                estructura_read statement_cuerpo_case
        |       estructura_write statement_cuerpo_case
        |       llamado_funcion statement_cuerpo_case
        |       expresiones statement_cuerpo_case
        |       BREAK SEMICOLON;     // SE TERMINA LA FUNCION  

// CONTINUES, BREAK AND RETURN

otras_palabras  ::=
                CONTINUE SEMICOLON
        |       BREAK   SEMICOLON
        |       RETURN return_variables  SEMICOLON;

return_variables    ::=
                    
        |       literal
        |       IDENTIFIER;

// VARIABLES LOCALES DE FUNCION ******************
statement_variables_locales_inicio ::=
        |       epsilon
                statement_variables_locales;

statement_variables_locales ::=
                declaracion_identificador 
        |       declaracion_identificador statement_variables_locales;  

// OPERADPRES *********************

operadores_unarios ::=
                PLUS_PLUS
        |       MINUS_MINUS;


operadores_binarios ::=
                PLUS
        |       MINUS
        |       MULT
        |       DIV
        |       MOD;

operadores_asignacion ::= 
                EQ
        |       PLUS_EQ
        |       MINUS_EQ
        |       MULT_EQ
        |       DIV_EQ;   


operadores_booleanos ::= 
                OROR
        |       ANDAND
        |       EQEQ
        |       GTEQ
        |       GT
        |       LTEQ
        |       LT
        |       NOTEQ;   

// LITERALES *************************

literal ::=
		INTEGER_LITERAL 
	|	FLOATING_POINT_LITERAL
	|	BOOLEAN_LITERAL 
	|	CHARACTER_LITERAL 
	|	STRING_LITERAL 
        |       HEX_LITERAL
        |       OCT_LITERAL
	|	NULL_LITERAL;

literal_numerico ::=
		INTEGER_LITERAL 
	|	FLOATING_POINT_LITERAL
        |       HEX_LITERAL
        |       OCT_LITERAL;

// TIPOS *****************
type	::=
		BOOLEAN
	|	INT
	|	CHAR
	|	FLOAT
        |       LONG
        |       SHORT;




// READ AND WRITE **************

estructura_read    ::=
                READ LPAREN  RPAREN SEMICOLON
        |       READ LPAREN  estructura_read_parametros RPAREN SEMICOLON
        |       READ  error:e{:parser.report_error("Error Semantico: Uso de READ",e);:}  SEMICOLON ;

estructura_read_parametros  ::=
               IDENTIFIER;

estructura_write   ::=
                WRITE LPAREN  expresiones RPAREN SEMICOLON
        |       WRITE error:e{:parser.report_error("Error Semantico: Uso de WRITE",e);:} SEMICOLON ;
                
estructura_write_parametros   ::=
                estructura_write_parametros_aux
        |       estructura_write_parametros_aux COMMA estructura_write_parametros;       

estructura_write_parametros_aux   ::=
                 IDENTIFIER
         |       literal;

// LLAMADO A FUNCION ********
llamado_funcion             ::=
                IDENTIFIER LPAREN  RPAREN SEMICOLON
        |       IDENTIFIER LPAREN  estructura_write_parametros_aux RPAREN SEMICOLON
        |       IDENTIFIER error:e{:parser.report_error("Error Semantico: LLAMADO DE FUNCION",e);:} SEMICOLON ;
               

//      EXPRESIONES
expresiones   ::= 
                  expresiones_statement SEMICOLON;

 
expresiones_statement ::=
                asignacion
        |       expresion_aritmetica  
        |       expresion_booleana ;

asignacion ::= 
                IDENTIFIER operadores_asignacion expresion_aritmetica ;      


expresion_aritmetica ::= 
                 expresion_aritmetica_unaria
        |        expresion_aritmetica_binaria
        |        LPAREN expresion_aritmetica RPAREN
        |        IDENTIFIER 
        |        literal;

expresion_aritmetica_unaria ::= 
                 operadores_unarios IDENTIFIER 
        |        IDENTIFIER operadores_unarios 
        |        MINUS literal_numerico
        |        MINUS IDENTIFIER;

expresion_aritmetica_binaria ::= 
                 expresion_aritmetica operadores_binarios expresion_aritmetica;
        

expresion_booleana ::= 
          |       expresion_aritmetica operadores_booleanos expresion_aritmetica
          |       NOT expresion_aritmetica
          |       LPAREN expresion_booleana RPAREN;
// ********** VACIO
epsilon ::= /*nothing */;
        


